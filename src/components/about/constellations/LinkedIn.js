/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useGLTF } from '@react-three/drei';
import model from '@/assets/models/linkedin.glb';
import { ConstellationMaterial } from '../shaders/constellation';
import { extend, useFrame, useThree } from '@react-three/fiber';
import { useControls } from 'leva';
import { useMemo, useState, useRef, useEffect } from 'react';
import { BufferAttribute } from 'three';
import { useSpring, animated as a } from '@react-spring/three';
import { useAboutStore } from '@/store';
import Lines from './Lines';

export function LinkedIn(props) {
  const { nodes } = useGLTF(model);
  const lineRef = useRef();
  const viewport = useThree((s) => s.viewport);
  const size = useThree((s) => s.size);
  const world = useAboutStore((s) => s.world);

  const [converged, setConverged] = useState(false);

  const { starSize, color1, color2, color3 } = useControls('stars', {
    color1: '#fffbd7',
    color2: '#dcf7ff',
    color3: '#d9d9ff',
    starSize: { value: 17.5, min: 1, max: 45, step: 0.1 },
  });

  const { displacement, lineOpacity, pointScale } = useSpring({
    displacement: converged ? 0 : 1,
    lineOpacity: converged ? 1 : 0,
    pointScale: converged ? 0.6 : 1,
  });

  const pos = useMemo(
    () => nodes.linkedin_merged.geometry.attributes.position,
    [nodes]
  );

  const pos2 = useMemo(() => {
    let count = nodes.linkedin_merged.geometry.attributes.position.count;

    let positions = [];

    // uniform spherical distribution of points with random radii
    for (let i = 0; i < count; i++) {
      let theta = Math.random() * 2 * Math.PI;
      let phi = Math.acos(2 * Math.random() - 1);
      let radius = Math.random() * 1.25 + 0.25;

      let x = radius * Math.sin(phi) * Math.cos(theta);
      let y = radius * Math.sin(phi) * Math.sin(theta);
      let z = radius * Math.cos(phi);

      positions.push(x, y, z);
    }

    return new BufferAttribute(new Float32Array(positions), 3);
  }, [nodes]);

  const sizes = useMemo(() => {
    let sz = [];
    let c = nodes.linkedin_merged.geometry.attributes.position.count;

    for (let i = 0; i < c; i++) {
      sz.push(Math.random() * 0.8 + 0.2);
    }

    return new BufferAttribute(new Float32Array(sz), 1);
  }, [nodes]);

  useFrame(() => {
    let rx = -world.rotation.x;

    if (rx >= 0.56 && rx <= 0.88) {
      if (!converged) setConverged(true);
    } else {
      if (converged) setConverged(false);
    }
  });

  return (
    <group scale={[0.05, 0.05, 0.05]} {...props} dispose={null}>
      <Lines
        positions={nodes.linkedin_1.geometry.attributes.position.array}
        width={0.001}
        visible={converged}
      />
      <Lines
        positions={nodes.linkedin_2.geometry.attributes.position.array}
        width={0.001}
        visible={converged}
      />
      <Lines
        positions={nodes.linkedin_3.geometry.attributes.position.array}
        width={0.001}
        visible={converged}
      />
      <Lines
        positions={nodes.linkedin_4.geometry.attributes.position.array}
        width={0.001}
        visible={converged}
      />

      <points>
        <bufferGeometry>
          <bufferAttribute attach={'attributes-position'} {...pos} />
          <bufferAttribute attach={'attributes-position2'} {...pos2} />
          <bufferAttribute attach={'attributes-size'} {...sizes} />
        </bufferGeometry>
        <ConstellationMaterial
          uPointSize={starSize * viewport.dpr * (size.height / 600)}
          uPointMultiplier={pointScale}
          uDisplacementFactor={displacement}
          uColor1={color1}
          uColor2={color2}
          uColor3={color3}
        />
      </points>
    </group>
  );
}

useGLTF.preload(model);
